#### 200. 岛屿数量

难度：中等

---

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 **示例 1：** 

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

 **示例 2：** 

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

 **提示：** 

*   `m == grid.length`
*   `n == grid[i].length`
*   `1 <= m, n <= 300`
*   `grid[i][j]` 的值为 `'0'` 或 `'1'`

---

深度搜索优先：

遍历每一格数据，如果当前格数据为 `1`，则岛屿数量加一，并且将四周（上下左右）的 `1` 变为 `0`，不断扩散（深度搜索）

```Go
func numIslands(grid [][]byte) int {
    res := 0
    var dfs func(grid [][]byte, i, j int)
    dfs = func(grid [][]byte, i, j int) {
        if grid[i][j] == '0' {
            return
        }
        m, n := len(grid), len(grid[0])
        grid[i][j] = '0'
        if i > 0 {
            dfs(grid, i - 1, j)
        }
        if i < m - 1 {
            dfs(grid, i + 1, j)
        }
        if j > 0 {
            dfs(grid, i, j - 1)
        }
        if j < n - 1 {
            dfs(grid, i, j + 1)
        }
    }
    for i := 0; i < len(grid); i++ {
        for j := 0; j < len(grid[0]); j++ {
            if grid[i][j] == '1' {
                dfs(grid, i, j)
                res ++
            }
        }
    }
    return res
}
```