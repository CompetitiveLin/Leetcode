#### 791. 自定义字符串排序

难度：中等

-------

给定两个字符串 `order` 和 `s` 。`order` 的所有单词都是  **唯一**  的，并且以前按照一些自定义的顺序排序。

对 `s` 的字符进行置换，使其与排序的 `order` 相匹配。更具体地说，如果在 `order` 中的字符 `x` 出现字符 `y` 之前，那么在排列后的字符串中， `x` 也应该出现在 `y` 之前。

返回 _满足这个性质的 `s` 的任意排列_ 。

 **示例 1:** 

```
输入: order = "cba", s = "abcd"
输出: "cbad"
解释: 
“a”、“b”、“c”是按顺序出现的，所以“a”、“b”、“c”的顺序应该是“c”、“b”、“a”。
因为“d”不是按顺序出现的，所以它可以在返回的字符串中的任何位置。“dcba”、“cdba”、“cbda”也是有效的输出。
```

 **示例 2:** 

```
输入: order = "cbafg", s = "abcd"
输出: "cbad"
```

 **提示:** 

*   `1 <= order.length <= 26`
*   `1 <= s.length <= 200`
*   `order` 和 `s` 由小写英文字母组成
*   `order` 中的所有字符都  **不同**

---

成功：

类似计数排序，使用一个额外数组记录字符串 `s` 中出现的**自定义顺序**，记录结束后按自定义顺序重复出现的次数拼凑即可。

当然，也可以使用哈希表。

```java
class Solution {
    public String customSortString(String order, String s) {
        int[] alphabet = new int[order.length()];
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < s.length(); i++){
            int index = order.indexOf(s.charAt(i));
            if(index != -1) alphabet[index]++;
            else sb.append("" + s.charAt(i));
        }
        for(int i = 0; i < order.length(); i++){
            while(alphabet[i]-- != 0){
                sb.append("" + order.charAt(i));
            }
        }
        return sb.toString();
    }
}
```

