#### 775. 全局倒置与局部倒置

难度：中等

---

给你一个长度为 `n` 的整数数组 `nums` ，表示由范围 `[0, n - 1]` 内所有整数组成的一个排列。

 **全局倒置**  的数目等于满足下述条件不同下标对 `(i, j)` 的数目：

*   `0 <= i < j < n`
*   `nums[i] > nums[j]`

 **局部倒置**  的数目等于满足下述条件的下标 `i` 的数目：

*   `0 <= i < n - 1`
*   `nums[i] > nums[i + 1]`

当数组 `nums` 中  **全局倒置**  的数量等于  **局部倒置**  的数量时，返回 `true` ；否则，返回 `false` 。

 **示例 1：** 

```
输入：nums = [1,0,2]
输出：true
解释：有 1 个全局倒置，和 1 个局部倒置。
```

 **示例 2：** 

```
输入：nums = [1,2,0]
输出：false
解释：有 2 个全局倒置，和 1 个局部倒置。
```

 

 **提示：** 

*   `n == nums.length`
*   `1 <= n <= 10^5`
*   `0 <= nums[i] < n`
*   `nums` 中的所有整数  **互不相同** 
*   `nums` 是范围 `[0, n - 1]` 内所有数字组成的一个排列

---

阅读题目后可以发现，局部倒置一定是全局倒置，因此**全局倒置的数量一定是大于等于全局倒置的数量**。

根据最后一条提示，

> `nums` 是范围 `[0, n - 1]` 内所有数字组成的一个排列

那么得到，若全局倒置的数量等于局部倒置的数量，则只能出现局部倒置，即只存在相邻数字的逆序，例如，`10324` 中的 `10` 和`32` 为相邻数字的逆序。

根据这个特点再结合数学知识，可以概括出该数组为 `01234...n` 序列中某两个相邻数字交换后得到的数组，也就是**每个数字与数组中以该数字为下标的数相差小于等于 `1`**，否则不成立。

```java
class Solution {
    public boolean isIdealPermutation(int[] nums) {
        for(int i = 0; i < nums.length; i++){
            if(Math.abs(nums[i] - i) > 1) return false;
        }
        return true;
    }
}
```

