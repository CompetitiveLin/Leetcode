#### 287. 寻找重复数

难度：中等

---

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有  **一个重复的整数**  ，返回  **这个重复的数**  。

你设计的解决方案必须  **不修改**  数组 `nums` 且只用常量级 `O(1)` 的额外空间。

 **示例 1：** 

```
输入：nums = [1,3,4,2,2]
输出：2
```

 **示例 2：** 

```
输入：nums = [3,1,3,4,2]
输出：3
```

 **提示：** 

*   `1 <= n <= 10^5`
*   `nums.length == n + 1`
*   `1 <= nums[i] <= n`
*   `nums` 中  **只有一个整数**  出现  **两次或多次**  ，其余整数均只出现  **一次** 

**进阶：**

*   如何证明 `nums` 中至少存在一个重复的数字?
*   你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？

---

类似于环形链表找环的入口：

以 `[1, 3, 4, 2, 2]` 为例，由下标对应到值有一层映射关系，即 `0 -> 1, 1 -> 3, 2 ->4, 3 -> 2, 4 -> 2`，将其串成一串得到下图：



![](https://pic.leetcode-cn.com/999e055b41e499d9ac704abada4a1b8e6697374fdfedc17d06b0e8aa10a8f8f6-287.png)

再利用快慢指针遍历该链表，可以得到快慢指针交界处，再初始化第三个指针为头位置，该指针与交界处的指针移动同样的距离即可得到环形链表入口处。

```Java
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0, fast = 0;
        do{
            slow = nums[slow];
            fast = nums[nums[fast]];
        }while(slow != fast);
        int cur = 0;
        while(cur != slow){
            cur = nums[cur];
            slow = nums[slow];
        }
        return cur;
    }
}
```