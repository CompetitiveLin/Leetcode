#### 39. 组合总和

难度：中等

---

给你一个  **无重复元素**  的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有  **不同组合**  ，并以列表形式返回。你可以按  **任意顺序**  返回这些组合。

`candidates` 中的  **同一个**  数字可以  **无限制重复被选取**  。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

 **示例 1：** 

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

 **示例 2：** 

```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

 **示例 3：** 

```
输入: candidates = [2], target = 1
输出: []
```

 **提示：** 

*   `1 <= candidates.length <= 30`
*   `2 <= candidates[i] <= 40`
*   `candidates` 的所有元素  **互不相同** 
*   `1 <= target <= 40`

---

**方法一：枚举选哪个**

从 `target` 开始，每次回溯都减或不减当前下标的值。本题用到剪枝在于先将数组按升序排序，如果当前下标的值小于 `target` 了，那么后续也不需要遍历了。

但与全排列不同的是，本题并不需要用到 `visited` 数组，而是需要记录下标的 `index` 变量：

- 排列问题，需要考虑顺序时，使用是否遍历过了的 `visited` 数组
- 组合问题，不考虑顺序时，使用记录下标的 `index` 变量

```Java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(candidates);
        backtrace(res, new ArrayList<>(), candidates, 0, target);
        return res;
    }

    private void backtrace(List<List<Integer>> res, List<Integer> temp, int[] candidates, int index, int target){
        if(target == 0){
            res.add(new ArrayList<>(temp));
            return;
        }
        for(int i = index; i < candidates.length; i++){
            if(target - candidates[i] < 0) return;
            temp.add(candidates[i]);
            backtrace(res, temp, candidates, i, target - candidates[i]);
            temp.remove(temp.size() - 1);
        }
    }
}
```

Go

```go
func combinationSum(candidates []int, target int) [][]int {
    res := [][]int{}
    var dfs func(index, remain int, temp []int)
    dfs = func(index, remain int, temp []int){
        if remain == 0 {
            res = append(res, slices.Clone(temp))	// 一定要复制一份
            return
        }
        if remain < 0 {
            return
        }
        for i := index; i < len(candidates); i++ {
            temp = append(temp, candidates[i])
            dfs(i, remain - candidates[i], temp)
            temp = temp[:len(temp) - 1]
        }
    }
    dfs(0, target, []int{})
    return res
}
```





**方法二：选或不选**

```go
func combinationSum(candidates []int, target int) [][]int {
    res := [][]int{}
    var dfs func(index, remain int, temp []int)
    dfs = func(index, remain int, temp []int){
        if index >= len(candidates) || remain < 0 {
            return
        }
        if remain == 0 {
            res = append(res, slices.Clone(temp))
            return
        }
        dfs(index + 1, remain, temp)
        temp = append(temp, candidates[index])
        dfs(index, remain - candidates[index], temp)
        temp = temp[:len(temp) - 1]
    }
    dfs(0, target, []int{})
    return res
}
```

