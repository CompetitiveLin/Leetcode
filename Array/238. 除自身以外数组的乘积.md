#### 238. 除自身以外数组的乘积

难度：中等

---

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据  **保证**  数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在   **32 位**  整数范围内。

请  **不要使用除法，** 且在 `O(n)` 时间复杂度内完成此题。

 **示例 1:** 

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

 **示例 2:** 

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

 **提示：** 

*   `2 <= nums.length <= 10^5`
*   `-30 <= nums[i] <= 30`
*    **保证**  数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在   **32 位**  整数范围内

 **进阶：** 你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组  **不被视为**  额外空间。）

---

法一：

利用两个数组分别从左往右/从右往左遍历，记录除当前下标值的前缀/后缀乘积，注意前缀数组的第一个值为一，后缀数组的最后一个值为一，最后再两者相乘即是输出数组

```go
func productExceptSelf(nums []int) []int {
    n := len(nums)
    leftArray, rightArray, output := make([]int, n), make([]int, n), make([]int, n)
    for i := 0; i < n; i++ {
        if i == 0 {
            leftArray[i] = 1
        } else {
            leftArray[i] = leftArray[i - 1] * nums[i - 1]
        }
    }
    for i := n - 1; i >= 0; i-- {
        if i == n - 1 {
            rightArray[i] = 1
        } else {
            rightArray[i] = rightArray[i + 1] * nums[i + 1]
        }
    }
    for i := 0; i < n; i++ {
        output[i] = leftArray[i] * rightArray[i]
    }

    return output
}
```



法二：

先在 `output` 输出数组上从左往右累乘，再从右往左累乘，用一个临时遍历记录从右往左累乘的数。

```Go
func productExceptSelf(nums []int) []int {
    n := len(nums)
    output := make([]int, n)
    for i := 0; i < n; i++ {
        if i == 0 {
            output[i] = 1
        } else {
            output[i] = output[i - 1] * nums[i - 1]
        }
    }
    temp := 1
    for i := n - 1; i >= 0; i-- {
        if i != n - 1 {
            output[i] *= temp
        }
        temp *= nums[i]
    }
    return output
}
```